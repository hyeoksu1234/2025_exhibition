"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/embla-carousel-auto-scroll";
exports.ids = ["vendor-chunks/embla-carousel-auto-scroll"];
exports.modules = {

/***/ "(ssr)/./node_modules/embla-carousel-auto-scroll/esm/embla-carousel-auto-scroll.esm.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/embla-carousel-auto-scroll/esm/embla-carousel-auto-scroll.esm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AutoScroll)\n/* harmony export */ });\nconst defaultOptions = {\n  direction: 'forward',\n  speed: 2,\n  startDelay: 1000,\n  active: true,\n  breakpoints: {},\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  rootNode: null\n};\n\nfunction getAutoScrollRootNode(emblaApi, rootNode) {\n  const emblaRootNode = emblaApi.rootNode();\n  return rootNode && rootNode(emblaRootNode) || emblaRootNode;\n}\n\nfunction AutoScroll(userOptions = {}) {\n  let options;\n  let emblaApi;\n  let destroyed;\n  let startDelay;\n  let timerId = 0;\n  let autoScrollActive = false;\n  let mouseIsOver = false;\n  let defaultScrollBehaviour;\n  function init(emblaApiInstance, optionsHandler) {\n    emblaApi = emblaApiInstance;\n    const {\n      mergeOptions,\n      optionsAtMedia\n    } = optionsHandler;\n    const optionsBase = mergeOptions(defaultOptions, AutoScroll.globalOptions);\n    const allOptions = mergeOptions(optionsBase, userOptions);\n    options = optionsAtMedia(allOptions);\n    if (emblaApi.scrollSnapList().length <= 1) return;\n    startDelay = options.startDelay;\n    destroyed = false;\n    defaultScrollBehaviour = emblaApi.internalEngine().scrollBody;\n    const {\n      eventStore\n    } = emblaApi.internalEngine();\n    const isDraggable = !!emblaApi.internalEngine().options.watchDrag;\n    const root = getAutoScrollRootNode(emblaApi, options.rootNode);\n    if (isDraggable) {\n      emblaApi.on('pointerDown', pointerDown);\n    }\n    if (isDraggable && !options.stopOnInteraction) {\n      emblaApi.on('pointerUp', pointerUp);\n    }\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, 'mouseenter', mouseEnter);\n    }\n    if (options.stopOnMouseEnter && !options.stopOnInteraction) {\n      eventStore.add(root, 'mouseleave', mouseLeave);\n    }\n    if (options.stopOnFocusIn) {\n      emblaApi.on('slideFocusStart', stopAutoScroll);\n    }\n    if (options.stopOnFocusIn && !options.stopOnInteraction) {\n      eventStore.add(emblaApi.containerNode(), 'focusout', startAutoScroll);\n    }\n    if (options.playOnInit) startAutoScroll();\n  }\n  function destroy() {\n    emblaApi.off('pointerDown', pointerDown).off('pointerUp', pointerUp).off('slideFocusStart', stopAutoScroll).off('settle', settle);\n    stopAutoScroll();\n    destroyed = true;\n    autoScrollActive = false;\n  }\n  function startAutoScroll() {\n    if (destroyed) return;\n    if (autoScrollActive) return;\n    emblaApi.emit('autoScroll:play');\n    const engine = emblaApi.internalEngine();\n    const {\n      ownerWindow\n    } = engine;\n    timerId = ownerWindow.setTimeout(() => {\n      engine.scrollBody = createAutoScrollBehaviour(engine);\n      engine.animation.start();\n    }, startDelay);\n    autoScrollActive = true;\n  }\n  function stopAutoScroll() {\n    if (destroyed) return;\n    if (!autoScrollActive) return;\n    emblaApi.emit('autoScroll:stop');\n    const engine = emblaApi.internalEngine();\n    const {\n      ownerWindow\n    } = engine;\n    engine.scrollBody = defaultScrollBehaviour;\n    ownerWindow.clearTimeout(timerId);\n    timerId = 0;\n    autoScrollActive = false;\n  }\n  function createAutoScrollBehaviour(engine) {\n    const {\n      location,\n      previousLocation,\n      offsetLocation,\n      target,\n      scrollTarget,\n      index,\n      indexPrevious,\n      limit: {\n        reachedMin,\n        reachedMax,\n        constrain\n      },\n      options: {\n        loop\n      }\n    } = engine;\n    const directionSign = options.direction === 'forward' ? -1 : 1;\n    const noop = () => self;\n    let bodyVelocity = 0;\n    let scrollDirection = 0;\n    let rawLocation = location.get();\n    let rawLocationPrevious = 0;\n    let hasSettled = false;\n    function seek() {\n      let directionDiff = 0;\n      previousLocation.set(location);\n      bodyVelocity = directionSign * options.speed;\n      rawLocation += bodyVelocity;\n      location.add(bodyVelocity);\n      target.set(location);\n      directionDiff = rawLocation - rawLocationPrevious;\n      scrollDirection = Math.sign(directionDiff);\n      rawLocationPrevious = rawLocation;\n      const currentIndex = scrollTarget.byDistance(0, false).index;\n      if (index.get() !== currentIndex) {\n        indexPrevious.set(index.get());\n        index.set(currentIndex);\n        emblaApi.emit('select');\n      }\n      const reachedEnd = options.direction === 'forward' ? reachedMin(offsetLocation.get()) : reachedMax(offsetLocation.get());\n      if (!loop && reachedEnd) {\n        hasSettled = true;\n        const constrainedLocation = constrain(location.get());\n        location.set(constrainedLocation);\n        target.set(location);\n        stopAutoScroll();\n      }\n      return self;\n    }\n    const self = {\n      direction: () => scrollDirection,\n      duration: () => -1,\n      velocity: () => bodyVelocity,\n      settled: () => hasSettled,\n      seek,\n      useBaseFriction: noop,\n      useBaseDuration: noop,\n      useFriction: noop,\n      useDuration: noop\n    };\n    return self;\n  }\n  function pointerDown() {\n    if (!mouseIsOver) stopAutoScroll();\n  }\n  function pointerUp() {\n    if (!mouseIsOver) startAutoScrollOnSettle();\n  }\n  function mouseEnter() {\n    mouseIsOver = true;\n    stopAutoScroll();\n  }\n  function mouseLeave() {\n    mouseIsOver = false;\n    startAutoScroll();\n  }\n  function settle() {\n    emblaApi.off('settle', settle);\n    startAutoScroll();\n  }\n  function startAutoScrollOnSettle() {\n    emblaApi.on('settle', settle);\n  }\n  function play(startDelayOverride) {\n    if (typeof startDelayOverride !== 'undefined') {\n      startDelay = startDelayOverride;\n    }\n    startAutoScroll();\n  }\n  function stop() {\n    if (autoScrollActive) stopAutoScroll();\n  }\n  function reset() {\n    if (autoScrollActive) {\n      stopAutoScroll();\n      startAutoScrollOnSettle();\n    }\n  }\n  function isPlaying() {\n    return autoScrollActive;\n  }\n  const self = {\n    name: 'autoScroll',\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying\n  };\n  return self;\n}\nAutoScroll.globalOptions = undefined;\n\n\n//# sourceMappingURL=embla-carousel-auto-scroll.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwtYXV0by1zY3JvbGwvZXNtL2VtYmxhLWNhcm91c2VsLWF1dG8tc2Nyb2xsLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4aGliaXRpb25fYXJjaGl2ZS8uL25vZGVfbW9kdWxlcy9lbWJsYS1jYXJvdXNlbC1hdXRvLXNjcm9sbC9lc20vZW1ibGEtY2Fyb3VzZWwtYXV0by1zY3JvbGwuZXNtLmpzPzUxZWYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGRpcmVjdGlvbjogJ2ZvcndhcmQnLFxuICBzcGVlZDogMixcbiAgc3RhcnREZWxheTogMTAwMCxcbiAgYWN0aXZlOiB0cnVlLFxuICBicmVha3BvaW50czoge30sXG4gIHBsYXlPbkluaXQ6IHRydWUsXG4gIHN0b3BPbkZvY3VzSW46IHRydWUsXG4gIHN0b3BPbkludGVyYWN0aW9uOiB0cnVlLFxuICBzdG9wT25Nb3VzZUVudGVyOiBmYWxzZSxcbiAgcm9vdE5vZGU6IG51bGxcbn07XG5cbmZ1bmN0aW9uIGdldEF1dG9TY3JvbGxSb290Tm9kZShlbWJsYUFwaSwgcm9vdE5vZGUpIHtcbiAgY29uc3QgZW1ibGFSb290Tm9kZSA9IGVtYmxhQXBpLnJvb3ROb2RlKCk7XG4gIHJldHVybiByb290Tm9kZSAmJiByb290Tm9kZShlbWJsYVJvb3ROb2RlKSB8fCBlbWJsYVJvb3ROb2RlO1xufVxuXG5mdW5jdGlvbiBBdXRvU2Nyb2xsKHVzZXJPcHRpb25zID0ge30pIHtcbiAgbGV0IG9wdGlvbnM7XG4gIGxldCBlbWJsYUFwaTtcbiAgbGV0IGRlc3Ryb3llZDtcbiAgbGV0IHN0YXJ0RGVsYXk7XG4gIGxldCB0aW1lcklkID0gMDtcbiAgbGV0IGF1dG9TY3JvbGxBY3RpdmUgPSBmYWxzZTtcbiAgbGV0IG1vdXNlSXNPdmVyID0gZmFsc2U7XG4gIGxldCBkZWZhdWx0U2Nyb2xsQmVoYXZpb3VyO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpSW5zdGFuY2UsIG9wdGlvbnNIYW5kbGVyKSB7XG4gICAgZW1ibGFBcGkgPSBlbWJsYUFwaUluc3RhbmNlO1xuICAgIGNvbnN0IHtcbiAgICAgIG1lcmdlT3B0aW9ucyxcbiAgICAgIG9wdGlvbnNBdE1lZGlhXG4gICAgfSA9IG9wdGlvbnNIYW5kbGVyO1xuICAgIGNvbnN0IG9wdGlvbnNCYXNlID0gbWVyZ2VPcHRpb25zKGRlZmF1bHRPcHRpb25zLCBBdXRvU2Nyb2xsLmdsb2JhbE9wdGlvbnMpO1xuICAgIGNvbnN0IGFsbE9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9uc0Jhc2UsIHVzZXJPcHRpb25zKTtcbiAgICBvcHRpb25zID0gb3B0aW9uc0F0TWVkaWEoYWxsT3B0aW9ucyk7XG4gICAgaWYgKGVtYmxhQXBpLnNjcm9sbFNuYXBMaXN0KCkubGVuZ3RoIDw9IDEpIHJldHVybjtcbiAgICBzdGFydERlbGF5ID0gb3B0aW9ucy5zdGFydERlbGF5O1xuICAgIGRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIGRlZmF1bHRTY3JvbGxCZWhhdmlvdXIgPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpLnNjcm9sbEJvZHk7XG4gICAgY29uc3Qge1xuICAgICAgZXZlbnRTdG9yZVxuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gISFlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpLm9wdGlvbnMud2F0Y2hEcmFnO1xuICAgIGNvbnN0IHJvb3QgPSBnZXRBdXRvU2Nyb2xsUm9vdE5vZGUoZW1ibGFBcGksIG9wdGlvbnMucm9vdE5vZGUpO1xuICAgIGlmIChpc0RyYWdnYWJsZSkge1xuICAgICAgZW1ibGFBcGkub24oJ3BvaW50ZXJEb3duJywgcG9pbnRlckRvd24pO1xuICAgIH1cbiAgICBpZiAoaXNEcmFnZ2FibGUgJiYgIW9wdGlvbnMuc3RvcE9uSW50ZXJhY3Rpb24pIHtcbiAgICAgIGVtYmxhQXBpLm9uKCdwb2ludGVyVXAnLCBwb2ludGVyVXApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdG9wT25Nb3VzZUVudGVyKSB7XG4gICAgICBldmVudFN0b3JlLmFkZChyb290LCAnbW91c2VlbnRlcicsIG1vdXNlRW50ZXIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdG9wT25Nb3VzZUVudGVyICYmICFvcHRpb25zLnN0b3BPbkludGVyYWN0aW9uKSB7XG4gICAgICBldmVudFN0b3JlLmFkZChyb290LCAnbW91c2VsZWF2ZScsIG1vdXNlTGVhdmUpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdG9wT25Gb2N1c0luKSB7XG4gICAgICBlbWJsYUFwaS5vbignc2xpZGVGb2N1c1N0YXJ0Jywgc3RvcEF1dG9TY3JvbGwpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdG9wT25Gb2N1c0luICYmICFvcHRpb25zLnN0b3BPbkludGVyYWN0aW9uKSB7XG4gICAgICBldmVudFN0b3JlLmFkZChlbWJsYUFwaS5jb250YWluZXJOb2RlKCksICdmb2N1c291dCcsIHN0YXJ0QXV0b1Njcm9sbCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBsYXlPbkluaXQpIHN0YXJ0QXV0b1Njcm9sbCgpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgZW1ibGFBcGkub2ZmKCdwb2ludGVyRG93bicsIHBvaW50ZXJEb3duKS5vZmYoJ3BvaW50ZXJVcCcsIHBvaW50ZXJVcCkub2ZmKCdzbGlkZUZvY3VzU3RhcnQnLCBzdG9wQXV0b1Njcm9sbCkub2ZmKCdzZXR0bGUnLCBzZXR0bGUpO1xuICAgIHN0b3BBdXRvU2Nyb2xsKCk7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBhdXRvU2Nyb2xsQWN0aXZlID0gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRBdXRvU2Nyb2xsKCkge1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBpZiAoYXV0b1Njcm9sbEFjdGl2ZSkgcmV0dXJuO1xuICAgIGVtYmxhQXBpLmVtaXQoJ2F1dG9TY3JvbGw6cGxheScpO1xuICAgIGNvbnN0IGVuZ2luZSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJXaW5kb3dcbiAgICB9ID0gZW5naW5lO1xuICAgIHRpbWVySWQgPSBvd25lcldpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGVuZ2luZS5zY3JvbGxCb2R5ID0gY3JlYXRlQXV0b1Njcm9sbEJlaGF2aW91cihlbmdpbmUpO1xuICAgICAgZW5naW5lLmFuaW1hdGlvbi5zdGFydCgpO1xuICAgIH0sIHN0YXJ0RGVsYXkpO1xuICAgIGF1dG9TY3JvbGxBY3RpdmUgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHN0b3BBdXRvU2Nyb2xsKCkge1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBpZiAoIWF1dG9TY3JvbGxBY3RpdmUpIHJldHVybjtcbiAgICBlbWJsYUFwaS5lbWl0KCdhdXRvU2Nyb2xsOnN0b3AnKTtcbiAgICBjb25zdCBlbmdpbmUgPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyV2luZG93XG4gICAgfSA9IGVuZ2luZTtcbiAgICBlbmdpbmUuc2Nyb2xsQm9keSA9IGRlZmF1bHRTY3JvbGxCZWhhdmlvdXI7XG4gICAgb3duZXJXaW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIHRpbWVySWQgPSAwO1xuICAgIGF1dG9TY3JvbGxBY3RpdmUgPSBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVBdXRvU2Nyb2xsQmVoYXZpb3VyKGVuZ2luZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgcHJldmlvdXNMb2NhdGlvbixcbiAgICAgIG9mZnNldExvY2F0aW9uLFxuICAgICAgdGFyZ2V0LFxuICAgICAgc2Nyb2xsVGFyZ2V0LFxuICAgICAgaW5kZXgsXG4gICAgICBpbmRleFByZXZpb3VzLFxuICAgICAgbGltaXQ6IHtcbiAgICAgICAgcmVhY2hlZE1pbixcbiAgICAgICAgcmVhY2hlZE1heCxcbiAgICAgICAgY29uc3RyYWluXG4gICAgICB9LFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBsb29wXG4gICAgICB9XG4gICAgfSA9IGVuZ2luZTtcbiAgICBjb25zdCBkaXJlY3Rpb25TaWduID0gb3B0aW9ucy5kaXJlY3Rpb24gPT09ICdmb3J3YXJkJyA/IC0xIDogMTtcbiAgICBjb25zdCBub29wID0gKCkgPT4gc2VsZjtcbiAgICBsZXQgYm9keVZlbG9jaXR5ID0gMDtcbiAgICBsZXQgc2Nyb2xsRGlyZWN0aW9uID0gMDtcbiAgICBsZXQgcmF3TG9jYXRpb24gPSBsb2NhdGlvbi5nZXQoKTtcbiAgICBsZXQgcmF3TG9jYXRpb25QcmV2aW91cyA9IDA7XG4gICAgbGV0IGhhc1NldHRsZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBzZWVrKCkge1xuICAgICAgbGV0IGRpcmVjdGlvbkRpZmYgPSAwO1xuICAgICAgcHJldmlvdXNMb2NhdGlvbi5zZXQobG9jYXRpb24pO1xuICAgICAgYm9keVZlbG9jaXR5ID0gZGlyZWN0aW9uU2lnbiAqIG9wdGlvbnMuc3BlZWQ7XG4gICAgICByYXdMb2NhdGlvbiArPSBib2R5VmVsb2NpdHk7XG4gICAgICBsb2NhdGlvbi5hZGQoYm9keVZlbG9jaXR5KTtcbiAgICAgIHRhcmdldC5zZXQobG9jYXRpb24pO1xuICAgICAgZGlyZWN0aW9uRGlmZiA9IHJhd0xvY2F0aW9uIC0gcmF3TG9jYXRpb25QcmV2aW91cztcbiAgICAgIHNjcm9sbERpcmVjdGlvbiA9IE1hdGguc2lnbihkaXJlY3Rpb25EaWZmKTtcbiAgICAgIHJhd0xvY2F0aW9uUHJldmlvdXMgPSByYXdMb2NhdGlvbjtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKDAsIGZhbHNlKS5pbmRleDtcbiAgICAgIGlmIChpbmRleC5nZXQoKSAhPT0gY3VycmVudEluZGV4KSB7XG4gICAgICAgIGluZGV4UHJldmlvdXMuc2V0KGluZGV4LmdldCgpKTtcbiAgICAgICAgaW5kZXguc2V0KGN1cnJlbnRJbmRleCk7XG4gICAgICAgIGVtYmxhQXBpLmVtaXQoJ3NlbGVjdCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhY2hlZEVuZCA9IG9wdGlvbnMuZGlyZWN0aW9uID09PSAnZm9yd2FyZCcgPyByZWFjaGVkTWluKG9mZnNldExvY2F0aW9uLmdldCgpKSA6IHJlYWNoZWRNYXgob2Zmc2V0TG9jYXRpb24uZ2V0KCkpO1xuICAgICAgaWYgKCFsb29wICYmIHJlYWNoZWRFbmQpIHtcbiAgICAgICAgaGFzU2V0dGxlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbmVkTG9jYXRpb24gPSBjb25zdHJhaW4obG9jYXRpb24uZ2V0KCkpO1xuICAgICAgICBsb2NhdGlvbi5zZXQoY29uc3RyYWluZWRMb2NhdGlvbik7XG4gICAgICAgIHRhcmdldC5zZXQobG9jYXRpb24pO1xuICAgICAgICBzdG9wQXV0b1Njcm9sbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIGNvbnN0IHNlbGYgPSB7XG4gICAgICBkaXJlY3Rpb246ICgpID0+IHNjcm9sbERpcmVjdGlvbixcbiAgICAgIGR1cmF0aW9uOiAoKSA9PiAtMSxcbiAgICAgIHZlbG9jaXR5OiAoKSA9PiBib2R5VmVsb2NpdHksXG4gICAgICBzZXR0bGVkOiAoKSA9PiBoYXNTZXR0bGVkLFxuICAgICAgc2VlayxcbiAgICAgIHVzZUJhc2VGcmljdGlvbjogbm9vcCxcbiAgICAgIHVzZUJhc2VEdXJhdGlvbjogbm9vcCxcbiAgICAgIHVzZUZyaWN0aW9uOiBub29wLFxuICAgICAgdXNlRHVyYXRpb246IG5vb3BcbiAgICB9O1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJEb3duKCkge1xuICAgIGlmICghbW91c2VJc092ZXIpIHN0b3BBdXRvU2Nyb2xsKCk7XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlclVwKCkge1xuICAgIGlmICghbW91c2VJc092ZXIpIHN0YXJ0QXV0b1Njcm9sbE9uU2V0dGxlKCk7XG4gIH1cbiAgZnVuY3Rpb24gbW91c2VFbnRlcigpIHtcbiAgICBtb3VzZUlzT3ZlciA9IHRydWU7XG4gICAgc3RvcEF1dG9TY3JvbGwoKTtcbiAgfVxuICBmdW5jdGlvbiBtb3VzZUxlYXZlKCkge1xuICAgIG1vdXNlSXNPdmVyID0gZmFsc2U7XG4gICAgc3RhcnRBdXRvU2Nyb2xsKCk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0dGxlKCkge1xuICAgIGVtYmxhQXBpLm9mZignc2V0dGxlJywgc2V0dGxlKTtcbiAgICBzdGFydEF1dG9TY3JvbGwoKTtcbiAgfVxuICBmdW5jdGlvbiBzdGFydEF1dG9TY3JvbGxPblNldHRsZSgpIHtcbiAgICBlbWJsYUFwaS5vbignc2V0dGxlJywgc2V0dGxlKTtcbiAgfVxuICBmdW5jdGlvbiBwbGF5KHN0YXJ0RGVsYXlPdmVycmlkZSkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnREZWxheU92ZXJyaWRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc3RhcnREZWxheSA9IHN0YXJ0RGVsYXlPdmVycmlkZTtcbiAgICB9XG4gICAgc3RhcnRBdXRvU2Nyb2xsKCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoYXV0b1Njcm9sbEFjdGl2ZSkgc3RvcEF1dG9TY3JvbGwoKTtcbiAgfVxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAoYXV0b1Njcm9sbEFjdGl2ZSkge1xuICAgICAgc3RvcEF1dG9TY3JvbGwoKTtcbiAgICAgIHN0YXJ0QXV0b1Njcm9sbE9uU2V0dGxlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzUGxheWluZygpIHtcbiAgICByZXR1cm4gYXV0b1Njcm9sbEFjdGl2ZTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG5hbWU6ICdhdXRvU2Nyb2xsJyxcbiAgICBvcHRpb25zOiB1c2VyT3B0aW9ucyxcbiAgICBpbml0LFxuICAgIGRlc3Ryb3ksXG4gICAgcGxheSxcbiAgICBzdG9wLFxuICAgIHJlc2V0LFxuICAgIGlzUGxheWluZ1xuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cbkF1dG9TY3JvbGwuZ2xvYmFsT3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuZXhwb3J0IHsgQXV0b1Njcm9sbCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJsYS1jYXJvdXNlbC1hdXRvLXNjcm9sbC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/embla-carousel-auto-scroll/esm/embla-carousel-auto-scroll.esm.js\n");

/***/ })

};
;